# examples/analyze_samples.py
"""
Additional analysis tools for flow-generated samples.

This script demonstrates how to analyze the physical properties of
configurations generated by the trained normalizing flow.
"""

import torch
import numpy as np
import matplotlib.pyplot as plt
from phi4_flow import Phi4Action, RealNVPFlow


def compute_correlation_function(samples: torch.Tensor) -> np.ndarray:
    """
    Compute the two-point correlation function G(r) = ⟨φ(0)φ(r)⟩.
    
    We average over all starting points and directions to improve statistics.
    
    Args:
        samples: Field configurations of shape (n_samples, L, L)
        
    Returns:
        Correlation function G(r) for r = 0, 1, ..., L//2
    """
    n_samples, L, _ = samples.shape
    max_r = L // 2
    
    correlations = np.zeros(max_r + 1)
    counts = np.zeros(max_r + 1)
    
    samples_np = samples.cpu().numpy()
    
    for sample in samples_np:
        for i in range(L):
            for j in range(L):
                for di in range(max_r + 1):
                    for dj in range(max_r + 1):
                        r = int(np.sqrt(di**2 + dj**2))
                        if r <= max_r:
                            ni, nj = (i + di) % L, (j + dj) % L
                            correlations[r] += sample[i, j] * sample[ni, nj]
                            counts[r] += 1
    
    return correlations / counts


def estimate_correlation_length(G: np.ndarray) -> float:
    """
    Estimate correlation length from exponential decay of G(r).
    
    We fit G(r) ~ exp(-r/ξ) for intermediate r values.
    
    Args:
        G: Correlation function array
        
    Returns:
        Estimated correlation length ξ
    """
    # Use points where G is positive and significant
    r_values = np.arange(len(G))
    mask = G > 0.01 * G[0]
    
    if mask.sum() < 3:
        return float('inf')
    
    # Linear fit to log(G) vs r
    log_G = np.log(G[mask])
    r_masked = r_values[mask]
    
    slope, _ = np.polyfit(r_masked, log_G, 1)
    
    return -1.0 / slope if slope < 0 else float('inf')


def analyze_samples(model_path: str = 'phi4_flow_model.pt', n_samples: int = 500):
    """
    Comprehensive analysis of flow-generated samples.
    
    Args:
        model_path: Path to saved model checkpoint
        n_samples: Number of samples to analyze
    """
    # Load model
    checkpoint = torch.load(model_path, map_location='cpu')
    params = checkpoint['action_params']
    
    L = params['L']
    action = Phi4Action(L, params['m_squared'], params['lambda_coupling'])
    flow = RealNVPFlow(L, n_layers=8, hidden_size=256)
    flow.load_state_dict(checkpoint['flow_state_dict'])
    flow.eval()
    
    print(f"Loaded model for L={L}, m²={params['m_squared']}, λ={params['lambda_coupling']}")
    
    # Generate samples
    print(f"\nGenerating {n_samples} samples...")
    with torch.no_grad():
        samples = flow.sample(n_samples)
    
    # Compute observables
    print("Computing observables...")
    
    # Magnetization
    magnetization = samples.mean(dim=(1, 2))
    mag_abs = magnetization.abs()
    
    # Energy (action)
    energies = action(samples)
    
    # Correlation function
    G = compute_correlation_function(samples)
    xi = estimate_correlation_length(G)
    
    # Print results
    print("\n" + "=" * 50)
    print("PHYSICAL OBSERVABLES")
    print("=" * 50)
    print(f"Mean magnetization ⟨M⟩:     {magnetization.mean():.4f} ± {magnetization.std():.4f}")
    print(f"Mean |M|:                   {mag_abs.mean():.4f} ± {mag_abs.std():.4f}")
    print(f"Mean-field prediction:      {action.mean_field_magnetization():.4f}")
    print(f"Mean energy ⟨E⟩:            {energies.mean():.2f} ± {energies.std():.2f}")
    print(f"Correlation length ξ:       {xi:.2f}")
    
    # Visualization
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    
    # Magnetization histogram
    axes[0, 0].hist(magnetization.numpy(), bins=50, density=True, alpha=0.7)
    axes[0, 0].axvline(x=action.mean_field_magnetization(), color='r', linestyle='--',
                       label=f'+MF = {action.mean_field_magnetization():.3f}')
    axes[0, 0].axvline(x=-action.mean_field_magnetization(), color='r', linestyle='--',
                       label=f'-MF = {-action.mean_field_magnetization():.3f}')
    axes[0, 0].set_xlabel('Magnetization M')
    axes[0, 0].set_ylabel('Probability Density')
    axes[0, 0].set_title('Magnetization Distribution')
    axes[0, 0].legend()
    
    # Energy histogram
    axes[0, 1].hist(energies.numpy(), bins=50, density=True, alpha=0.7)
    axes[0, 1].set_xlabel('Energy')
    axes[0, 1].set_ylabel('Probability Density')
    axes[0, 1].set_title('Energy Distribution')
    
    # Correlation function
    r = np.arange(len(G))
    axes[1, 0].semilogy(r, G, 'o-')
    if xi < float('inf'):
        axes[1, 0].semilogy(r, G[0] * np.exp(-r / xi), '--', label=f'ξ = {xi:.2f}')
        axes[1, 0].legend()
    axes[1, 0].set_xlabel('Distance r')
    axes[1, 0].set_ylabel('G(r)')
    axes[1, 0].set_title('Two-Point Correlation Function')
    axes[1, 0].grid(True, alpha=0.3)
    
    # Sample configuration
    im = axes[1, 1].imshow(samples[0].numpy(), cmap='coolwarm', vmin=-3, vmax=3)
    axes[1, 1].set_title(f'Sample Configuration, M = {samples[0].mean():.3f}')
    axes[1, 1].axis('off')
    plt.colorbar(im, ax=axes[1, 1])
    
    plt.tight_layout()
    plt.savefig('sample_analysis.png', dpi=150)
    print("\nAnalysis saved to sample_analysis.png")
    
    return {
        'magnetization_mean': float(magnetization.mean()),
        'magnetization_std': float(magnetization.std()),
        'mag_abs_mean': float(mag_abs.mean()),
        'energy_mean': float(energies.mean()),
        'energy_std': float(energies.std()),
        'correlation_length': xi
    }


if __name__ == "__main__":
    analyze_samples()